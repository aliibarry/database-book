[["index.html", "Sequencing databases in Shiny Chapter 1 Overview 1.1 Shiny 1.2 Workflow", " Sequencing databases in Shiny AMB and NZ 2023-03-08 Chapter 1 Overview Here we will describe how to build a Shiny app for sequencing data using the code base described in A simple database framework for hosting and visualising sequencing data through Shiny (CITATION HERE). A working example of this app is hosted at https://livedataoxford.shinyapps.io/drg-directory/ and the code base is provided at https://github.com/aliibarry/omics-database. A previous version of https://livedataoxford.shinyapps.io/drg-directory/ was first published in Barry et al. 2023 but was updated here to reflect a more developer-friendly code base along with addition features (eg. network integration). 1.1 Shiny If you are completely new to Shiny, we recommend working through some short tutorials first, just to wrap your head around the structure https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/. 1.2 Workflow Data processing (2) Prepare tables (count, differential analysis, column data) Compile into a .RData or .db User interface (3) Write descriptions for each dataset and save them in .\\des\\* encouraged select appropriate plots and add descriptions encouraged choose title + logo optional customize aesthetic Server (4) Create a description dataframe des_df for the datasets included Specify directory storing your data optional customize figure aesthetic by modifying provided functions optional build your own functions (and link to the UI) Deploy (5) Deploy your app using rsconnect::deployApp() Happy building! This work is licensed under a Creative Commons Attribution 4.0 International License. "],["data.html", "Chapter 2 Data Processing 2.1 Preparation 2.2 Species (optional) 2.3 RData (option 1) 2.4 Building an SQL database via R (recommended)", " Chapter 2 Data Processing img { display:block; float:none; margin-left:auto; margin-right:auto; } Prepare data tables (minimum: count matrix, column data) Compile all data into an .RData or .db object. 2.1 Preparation To implement this app, you will need three types of data: Count tables in ./data/CountTables/ folder X Sample50_BALB.c_SHAM_M Sample51_BALB.c_SHAM_M Sample55_BALB.c_SHAM_F Sample56_BALB.c_SHAM_F Sample57_BALB.c_SHAM_F Sample58_B10.D2_SHAM_M Sample60_B10.D2_SHAM_M Sample67_B10.D2_SHAM_F Sample71_BALB.c_SHAM_M Sample77_B10.D2_SHAM_F Sample88_B10.D2_SHAM_M Sample49_BALB.c_SNI_M Sample64_BALB.c_SNI_F Sample65_BALB.c_SNI_F Sample69_B10.D2_SNI_F Sample70_BALB.c_SNI_M Sample76_B10.D2_SNI_F Sample78_B10.D2_SNI_F Sample89_B10.D2_SNI_M Sample90_B10.D2_SNI_M symbol ENSMUSG00000000001 20.6460082 20.9684737 25.6051105 17.9245459 21.8279448 23.8898091 20.8612482 21.1079774 21.9353412 19.8810344 25.4903826 23.2414339 26.0955758 24.5983920 22.3698430 25.4514816 23.2571636 25.0393354 21.4696758 21.4316521 Gnai3 ENSMUSG00000000003 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 Pbsn ENSMUSG00000000028 1.2444692 1.0386601 1.4225152 0.8771354 0.7774382 0.9572740 0.6793672 0.8532159 0.9904448 0.8884526 1.1943520 1.4496099 1.0502148 0.9892706 0.8066116 0.8839994 0.9460189 0.9714055 0.9352520 0.9411879 Cdc45 ENSMUSG00000000031 146.6304065 78.6870749 279.4541932 122.2226711 86.5995137 385.7192026 402.3015644 373.7624763 83.4889245 416.2586323 523.7706518 34.6120591 215.3297763 259.9150108 642.1622405 103.1170442 510.7111982 497.6381737 213.8979427 462.2669044 H19 ENSMUSG00000000037 0.0673974 0.0434038 0.0736720 0.0567710 0.0603054 0.0782123 0.0638765 0.0663909 0.0661561 0.0811122 0.1074937 0.0509788 0.0717639 0.0585030 0.0728068 0.0970444 0.0831925 0.1111677 0.0729349 0.0880621 Scml2 ENSMUSG00000000049 0.0895870 0.0961564 0.0699482 0.0611854 0.1214547 0.1831722 0.1309992 0.1764983 0.0713003 0.1952917 0.2609194 0.1016442 0.0931727 0.0818572 0.1539641 0.1098845 0.2628942 0.1581742 0.1856444 0.2387010 Apoh   Column Data (abbrev: colData) in ./data/ColDatas/ folder This contains the info about each sample The colnames of colData should include Population, Timepoint, Sex, Dataset, and Species If your experiment does not separate those samples based on any of those parameters, you will need to create a column that specifies this. E.g. if your samples are of mixed sex, you can creates a Sex column containing mixed for all samples. X Sample Population Condition Sex Sample_Pop_Cond_Sex Dataset Species Timepoint Sample50_BALB.c_SHAM_M Sample50 BALB.c SHAM M Sample50_BALB.c_SHAM_M Bulk DRG Mouse (DRG) na Sample51_BALB.c_SHAM_M Sample51 BALB.c SHAM M Sample51_BALB.c_SHAM_M Bulk DRG Mouse (DRG) na Sample55_BALB.c_SHAM_F Sample55 BALB.c SHAM F Sample55_BALB.c_SHAM_F Bulk DRG Mouse (DRG) na Sample56_BALB.c_SHAM_F Sample56 BALB.c SHAM F Sample56_BALB.c_SHAM_F Bulk DRG Mouse (DRG) na Sample57_BALB.c_SHAM_F Sample57 BALB.c SHAM F Sample57_BALB.c_SHAM_F Bulk DRG Mouse (DRG) na Sample58_B10.D2_SHAM_M Sample58 B10.D2 SHAM M Sample58_B10.D2_SHAM_M Bulk DRG Mouse (DRG) na   Differential expression data frames (abbrev: deg_df) in ./data/DegData/ folder This data file contains the log2FoldChange and statistics of one case vs control An experiment can have multiple deg_df files baseMean log2FoldChange lfcSE stat pvalue padj symbol Population ENSMUSG00000109908 10.737773 6.453185 4.103313 1.572677 NA NA NA b10d2 ENSMUSG00000096108 4.372395 -6.405612 3.800576 -1.685432 0.0919053 NA NA b10d2 ENSMUSG00000095889 3.541538 -6.168911 4.228860 -1.458765 0.1446299 NA NA b10d2 ENSMUSG00000073494 5.130631 5.941862 1.068377 5.561578 0.0000000 NA Sh2d1b2 b10d2 ENSMUSG00000036357 3.708027 5.483357 1.130411 4.850764 0.0000012 NA Gpr101 b10d2 ENSMUSG00000076538 3.050185 -5.384935 1.643832 -3.275843 0.0010535 NA NA b10d2 2.2 Species (optional) If your data contains different species, you will also need datasets that allow you map gene symbols/IDs between species. We have provided an option using the biomaRt library. library(&quot;biomaRt&quot;) mouse = useMart(&quot;ensembl&quot;, dataset = &quot;mmusculus_gene_ensembl&quot;, verbose = TRUE, host = &quot;https://dec2021.archive.ensembl.org&quot;) human = useMart(&quot;ensembl&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;, verbose = TRUE, host = &quot;https://dec2021.archive.ensembl.org&quot;) geneV1 = getLDS(attributes = c(&quot;mgi_symbol&quot;,&quot;ensembl_gene_id&quot;), filters = &quot;ensembl_gene_id&quot;, values = count$X, mart = mouse, attributesL = c(&quot;hgnc_symbol&quot;, &quot;ensembl_gene_id&quot;, &quot;description&quot;), martL = human, uniqueRows=T) colnames(geneV1) = c(&quot;mgi_symbol&quot;, &quot;mouse_gene_id&quot;, &quot;hgnc_symbol&quot;, &quot;human_gene_id&quot;) mgi_symbol mouse_gene_id hgnc_symbol human_gene_id NA mt-Nd4l ENSMUSG00000065947 MT-ND4L ENSG00000212907 mitochondrially encoded NADH:ubiquinone oxidoreductase core subunit 4L [Source:HGNC Symbol;Acc:HGNC:7460] mt-Co1 ENSMUSG00000064351 MT-CO1 ENSG00000198804 mitochondrially encoded cytochrome c oxidase I [Source:HGNC Symbol;Acc:HGNC:7419] mt-Nd1 ENSMUSG00000064341 MT-ND1 ENSG00000198888 mitochondrially encoded NADH:ubiquinone oxidoreductase core subunit 1 [Source:HGNC Symbol;Acc:HGNC:7455] mt-Nd5 ENSMUSG00000064367 MT-ND5 ENSG00000198786 mitochondrially encoded NADH:ubiquinone oxidoreductase core subunit 5 [Source:HGNC Symbol;Acc:HGNC:7461] mt-Atp6 ENSMUSG00000064357 MT-ATP6 ENSG00000198899 mitochondrially encoded ATP synthase membrane subunit 6 [Source:HGNC Symbol;Acc:HGNC:7414] mt-Nd2 ENSMUSG00000064345 MT-ND2 ENSG00000198763 mitochondrially encoded NADH:ubiquinone oxidoreductase core subunit 2 [Source:HGNC Symbol;Acc:HGNC:7456] 2.3 RData (option 1) You can store data frames into .RData using the save() function. For example, we can use the save() function to save the count data frame to a file called my_data.RData. save(count, file = &quot;my_data.RData&quot;) To load the data frame from the .RData file later, you can use the load() function in your server. Y load(&quot;my_data.RData&quot;) # add to server NOTE, some functions will need to be modified to read from a .RData instead. This can be done by uncommentng the relevant lines of code. For example: shiny::observeEvent(input$load, { if (include_count == TRUE){ # query count datasets ## comment here for .RData file # for database { if (species == &quot;human&quot;) { sql = paste(&quot;SELECT * FROM&quot;, count_df, &quot;WHERE mgi_symbol = ?&quot;) } else{ sql = paste(&quot;SELECT * FROM&quot;, count_df, &quot;WHERE symbol = ?&quot;) } filt = RSQLite::dbGetPreparedQuery(conn, sql, bind.data=data.frame(symbol=genes())) filt = as.data.frame(filt) } ## uncomment here for .RData file # using R Data { # if (species == &quot;human&quot;){ # filt = count_df[count_df$mgi_symbol %in% genes(),] # X = rownames(filt) # filt = cbind(X, filt) # # } # else { # filt = count_df[count_df$symbol %in% genes(),] # X = rownames(filt) # filt = cbind(X, filt) # } } If you plan to store data this way, move to the User Interface section now. If you are working with larger amounts of data, you may find it useful to set up an SQL database (recommended, below). 2.4 Building an SQL database via R (recommended) While .RData files can be useful small or medium-sized datasets in R, SQL databases provide a more powerful and flexible solution for managing large, complex datasets that need to be shared, queried, and analyzed by multiple users or integrated with other tools and applications. An SQLite database consists of one or more tables, which are composed of rows and columns. An RSQLite .db object is a database connection to a SQLite database file through R. The following functions will be useful in creating and updating the .db object in R. Here, we provide an overview for bulk count data. Seurat objects (for sc/snRNA-seq or ATAC-seq) are read in separately. # This function connects to a SQLite database file called `example_database.db` db_dir = &quot;example_database.db&quot; conn &lt;- dbConnect(RSQLite::SQLite(), db_dir) # This function stores dataframe objects into `.db` object dbWriteTable(conn, name = &quot;count_df&quot;, value = count) 2.4.1 SQL manipulation # List table names that you have already stored dbListTables(conn) ## [1] &quot;count_df&quot; Each table in a SQLite database has a schema that defines the columns in the table and their data types. In R, you can retrieve the schema of a table using the dbListFields() function, which returns a character vector of the column names. # Get the schema of the &quot;count_df&quot; table fields &lt;- dbListFields(conn, &quot;count_df&quot;) # Modify a table by using &#39;overwrite&#39; argument dbWriteTable(conn, name = &quot;count_df&quot;, value = count_modified, overwrite = TRUE) # Delete a table dbRemoveTable(conn, &quot;count_df&quot;) The dbGetQuery() function in RSQLite allows you to execute SQL queries and return the results as a data frame. # Select all rows from the &quot;count_df&quot; table result &lt;- dbGetQuery(conn, &quot;SELECT * FROM count_df&quot;) # Close the connection after you stored all tables dbDisconnect(conn) These functions are sufficient for users without prior knowledge in the RSQLite package. Further tutorials can be found at https://www.datacamp.com/tutorial/sqlite-in-r 2.4.2 Processing multiple files If your experimental data contains multiple files, it can become labor intensive to write tables one by one. To reduce the burden, you can read files by folders.  Read all count tables in ./data/CountTables folder into .db object, using their file names as table names. # all file names Counts &lt;- str_sort(list.files(path = &quot;./data/CountTables&quot;, pattern = &quot;*.csv&quot;)) # names of the count tables # name each file as their file name without &quot;.csv&quot; suffix names = as.vector(substr(Counts, 0, nchar(Counts) - 4)) # read files into database, using their file names as table names for (i in 1:length(names)){ name = names[i] value = read.csv(paste0(&quot;./data/CountTables/&quot;, Counts[i]), header = TRUE) dbWriteTable(conn, name, value) }  Read ColDatas files in ./data/ColDatas directory into tables. CDs &lt;- str_sort(list.files(path = &quot;./data/ColDatas&quot;, pattern = &quot;*.csv&quot;)) # names of colDatas names &lt;- substr(CDs, 0, nchar(CDs) - 4)# assign name # read in colData for (i in 1:length(names)) { name = names[i] value = read.csv(paste0(&quot;./data/ColDatas/&quot;, CDs[i]), header = TRUE, row.names = 1) dbWriteTable(conn, name, value, row.names = TRUE, overwrite = TRUE) } Reading in differential expression files in ./data/DegData/ directory: You can store them into different sub-directories based on species, as illustrated here. A combined deg_df for each species is generated and stored, which makes meta-analysis and cross-species comparison easier. In addition, since some experiments contain more than one differential expression analysis file, they are combined into one for each experiment, as illustrated below. To do this, you will need to store multiples into a folder for each study. A schematic illustration is shown below: # table names for files ## assign names here deg_df_names = c(&quot;subtype_deg_df&quot;, &quot;mouse_deg_df&quot;, &quot;rat_deg_df&quot;, &quot;ipsc_deg_df&quot;, &quot;db_deg_df&quot;, &quot;cts_deg_df&quot;) # you need to specify the names of the dataset (experiments) and store them in the list below ## assign names here Dataset = c(&quot;mouse/Subtype DRG (Barry)/&quot;, &quot;mouse/Mouse DRG Bulk/&quot;, &quot;rat/Rat DRG Bulk/&quot;, &quot;human/Human iPSC HSN1/&quot;, &quot;human/Human skin Diabetes/&quot;, &quot;human/Human skin Carpal Tunnel (CTS)/&quot;) ## just run this human_deg_df = data.frame() mouse_deg_df = data.frame() rat_deg_df = data.frame() # for each experiment for (j in 1:length(Dataset)) { # name of experiment name = Dataset[j] # species species = unlist(strsplit(name, split = &quot;/&quot;))[[1]] # DEs are a list of datasets in this experiment DEs = str_sort(list.files(path = paste(&quot;./data/DegData/&quot;, name, sep=&quot;&quot;), pattern = &quot;*.csv&quot;)) DE_names &lt;- substr(DEs, 0, nchar(DEs) - 4)# assign name to each population deg_list = list() # read in those datasets into one dataframes for each experiment for (i in 1:length(DE_names)) { df_name = DE_names[i] value = read.csv(paste(&quot;./data/DegData/&quot;, name, DEs[i], sep=&quot;&quot;), header = TRUE, row.names = 1) deg_list = append(deg_list, list(value)) } dataset_combine_deg = generate_degdf(deg_list, DE_names, unlist(strsplit(name, split = &quot;/&quot;))[[2]]) dbWriteTable(conn, deg_df_names[j], dataset_combine_deg) # add to species-specific lists of data frames if (species == &quot;human&quot;){ human_deg_df = rbind(human_deg_df, dataset_combine_deg) } if (species == &quot;mouse&quot;){ mouse_deg_df = rbind(mouse_deg_df, dataset_combine_deg) } if (species == &quot;rat&quot;){ rat_deg_df = rbind(rat_deg_df, dataset_combine_deg) } } # write species deg_df into table dbWriteTable(conn, &quot;mouse_all_deg_df&quot;, mouse_deg_df) dbWriteTable(conn, &quot;human_deg_df&quot;, human_deg_df) dbWriteTable(conn, &quot;rat_deg_df&quot;, rat_deg_df) Now, the .db object should contain all data required to run your app. "],["ui.html", "Chapter 3 User Interface 3.1 Basic structure 3.2 Header 3.3 Sidebar 3.4 Body", " Chapter 3 User Interface img { display:block; float:none; margin-left:auto; margin-right:auto; } Write descriptions for each dataset and save them in .\\des\\DATASETNAME.Rhtml Modify titles and descriptions At the most basic level, no changes are needed here, although customization is recommended (eg. choose a title, add descriptions). Throughout this app, description files for each page are loaded in as .Rhtml or .Rmd files, which can be rendered in R. # example descriptions includeHTML(&quot;network.Rhtml&quot;) includeMarkdown(&quot;userguide.Rmd&quot;) Details are below, and basic UI tutorials can be found at https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/. 3.1 Basic structure A Shiny dashboard UI typically consists of three main parts, contained within dashboardPage: Dashboard header: This is the top part of the dashboard, which contains the logo or title of the dashboard, and any navigation menus or links. Dashboard sidebar: This is the vertical bar on the left-hand side of the dashboard that contains input controls, such as buttons, sliders, dropdown menus, or text inputs. The sidebar allows users to interact with the dashboard and filter or manipulate the data displayed in the main panel. Dashboard body/main panel: This is the main part of the dashboard, which displays the data or visualizations based on the input controls selected in the sidebar. The main panel can contain any type of output, such as plots, tables, or text, and can be updated dynamically based on user input. Places commented in red texts are sites for customisation. Otherwise, this does not need to be modified 3.2 Header shinydashboard::dashboardHeader(title= &quot;The Database&quot;, ## Customise title titleWidth = 225) 3.3 Sidebar The sidebar contains a gene search input and tabs, which allow you to switch between different pages. The names of each tab can be customised by changing the label. ### this doesn&#39;t need to be altered, unless you want a footer or to change labels shinydashboard::dashboardSidebar(width = 225, sidebarMenu( id = &quot;tabs&quot;, # gene search shiny::selectizeInput( inputId = &quot;geneid&quot;, label = &quot;Search Genes:&quot;, multiple = TRUE, choices = NULL ), # file upload shiny::fileInput(&quot;file&quot;, label = &quot;Upload File:&quot;, accept = c( &#39;text/csv&#39;, &#39;text/comma-separated-values&#39;, &#39;text/tab-separated-values&#39;, &#39;text/plain&#39;, &#39;.csv&#39;, &#39;.txt&#39;, &#39;.tsv&#39;)), # clear button actionButton(&quot;reset&quot;, &quot;Clear&quot;), # Filters for dataset shiny::selectizeInput( inputId = &quot;sex&quot;, label = &quot;Select Sex:&quot;, choices = c(&#39;Both&#39;, &#39;Separate&#39;), selected = &#39;Both&#39;), # Sidebar menu for tabs (pages) shinydashboard::menuItem(&quot;Home&quot;, tabName = &quot;tabhome&quot;, icon = icon(&quot;home&quot;), badgeLabel = &quot;Start Here!&quot;, badgeColor = &quot;green&quot;), shinydashboard::menuItem(&quot;Grouped Analysis&quot;, tabName = &quot;tabmeta&quot;, icon = icon(&quot;dashboard&quot;)), shinydashboard::menuItem(&quot;Individual Analysis&quot;, tabName = &quot;tabdata&quot;, icon = icon(&quot;database&quot;)), shinydashboard::menuItem(&quot;Network Analysis&quot;, tabName = &quot;tabnet&quot;, icon = icon(&quot;circle-nodes&quot;)), shinydashboard::menuItem(&quot;User Guide&quot;, tabName = &quot;tabcode&quot;, icon = icon(&quot;folder-open&quot;)), shinydashboard::menuItem(&quot;Contact&quot;, tabName = &quot;tabguide&quot;, icon = icon(&quot;circle-nodes&quot;)), br(), br() ), ## Footer can be added ) 3.4 Body In the body, the tabItems with corresponding values for tabName: ### structure overview, each tab described below dashboardBody( tabItems( # First tab content tabItem(tabName = &quot;tabhome&quot;, # content ), # Second tab content tabItem(tabName = &quot;tabmeta&quot;, # content ), # other tabs ) ) 3.4.1 Homepage The homepage displays the title and general description of the app, which can be customised by the user at places commented in red text. shinydashboard::tabItem(tabName = &quot;tabhome&quot;, shinydashboard::box( width = 12, status = &quot;primary&quot;, column(width = 6, offset = 4, ## place for adding titles h1(strong(&quot;Title&quot;))), column(width = 8, offset = 2, ## place for customising descriptions h4(&quot;ADD TEXT&quot;) ), column(width = 4, offset = 4, actionButton(&quot;metaa&quot;,&quot;Meta Analysis&quot;, class = &quot;btn-success btn-lg btn-block&quot;, icon = icon(&quot;dashboard&quot;)), actionButton(&quot;inda&quot;,&quot;Individual Analysis&quot;, class = &quot;btn-success btn-lg btn-block&quot;, icon = icon(&quot;database&quot;)), actionButton(&quot;neta&quot;,&quot;Network Analysis&quot;, class = &quot;btn-success btn-lg btn-block&quot;, icon = icon(&quot;circle-nodes&quot;)), br(),br() ) ) ) 3.4.2 Grouped comparisons Grouped comparisons contains integrative visualisation of multiple datasets. This page contains a table containing descriptions of each dataset, as well as integrative plots. Each item is contained within boxes, and their width can be adjusted by changing the width parameter. There are three plots displayed in the example: Dot plot showing gene expression changes. Dot plot showing scRNA gene expression. Dot plot showing differential gene expression of genes. shinydashboard::tabItem(tabName=&quot;tabmeta&quot;, br(), shiny::fluidRow( shinydashboard::box(status = &quot;primary&quot;, width = 12, title = &quot;Choose Datasets for Meta-Analysis&quot;, solidHeader = TRUE, ## description p(&quot;ADD TEXT HERE&quot;), hr(), # table containing information of datasets DT::dataTableOutput(&quot;meta_table&quot;), collapsible = TRUE), ), br(), # buttons fluidRow( column(12,offset = 0, shiny::actionButton(&quot;load&quot;, &quot;Plot Graphs&quot;, icon = icon(&quot;play-circle&quot;)), shiny::downloadButton(&quot;combineplot&quot;, &quot;Generate code&quot;), shiny::downloadButton(&quot;combineplots&quot;, &quot;Download Plots&quot;) ) ), br(), shiny::fluidRow( # dot plots for bulk and single RNA sequencing ## comment out plots that you don&#39;t need shinydashboard::box(width = 12, title = &quot;Naive&quot;, collapsible = TRUE, solidHeader = TRUE, status = &quot;primary&quot;, plotcombine_ui(&quot;dot&quot;), plothomescdot_ui(&quot;homespat&quot;) ) ), fluidRow( # DEG plots shinydashboard::box(width = 12, title = &quot;Differential Gene Analysis&quot;, collapsible = TRUE, solidHeader = TRUE, status = &quot;primary&quot;, deg_combine_ui(&quot;deg_plot&quot;)) ) ) 3.4.3 Individual Analysis The information and plots for a dataset can be displayed after selection. Different from previous pages, this page contains a dynamic UI that reacts to the user input (i.e. the dataset that users clicked in the table). This is achieved by the uiOutput() function, which tells Shiny when the pages should be rendered. The UI for each indiviual page is stored in a function shinypageUI(), which is called with different parameters in response to different datasets selected. ### this doesn&#39;t need to be altered shinydashboard::tabItem(tabName = &quot;tabdata&quot;, fluidRow( # a table that allows selection of a single dataset for visualisation shinydashboard::box(status = &quot;primary&quot;, solidHeader = TRUE, width = 12, title = &quot;Choose A Dataset for Individual Analysis&quot;, DT::dataTableOutput(&quot;dataset_table&quot;), helpText(&quot;Select one dataset for meta-analysis by clicking on rows. Click again to deselect a dataset.&quot;), collapsible = TRUE) ), br(), fluidRow( # a ui that is responsive to dataset selected uiOutput(&quot;shinypages&quot;) ) ) The components included in each dataset are shown below. The code for each component is shown after, but does not need to be altered, other than changing title for control and condition boxes. The shinypageUI() function: #&#39; The UI function for each individual dataset page #&#39; #&#39; @param datasetTitle The title for the page #&#39; @param includedeg A Boolean value stating whether to include differential expression plots and tables #&#39; @param volc_title The title for volcano plots #&#39; @param include_subtype A Boolean value stating whether to include plots for different sub-populations. #&#39; @param des_dir A directory for the description files. Default = NULL. #&#39; @param image_dir A directory for any images. Default = NULL. #&#39; @param includegoi A Boolean stating whether to include result count table for selected genes. shinypageUI &lt;- function(id, datasetTitle, includedeg = FALSE, volc_title = NULL, include_subtype = FALSE, des_dir = NULL, image_dir = NULL, includegoi = TRUE, include_count = TRUE) { shiny::fluidPage( shiny::fluidRow( # Description for dataset shinydashboard::box(title = datasetTitle, width = 12, status = &quot;primary&quot;, solidHeader = TRUE, if (is.null(des_dir) == FALSE) {includeHTML(des_dir)}, ## links description files if (is.null(image_dir) == FALSE) {img(src = image_dir, height = 150, width = 400)} ) ), br(), # buttons shiny::actionButton(NS(id, &quot;load&quot;), &quot;Plot Graphs&quot;, icon = icon(&quot;play-circle&quot;)), shiny::downloadButton(NS(id,&quot;report&quot;), &quot;Generate Code&quot;), shiny::downloadButton(NS(id,&quot;plots&quot;), &quot;Download Data&quot;), shiny::helpText(em(&quot;Load data before plotting.&quot;)), # plots using count data if (include_count == TRUE){ shiny::fluidRow( # gene expression dotplot shinydashboard::box(title = &quot;Control&quot;, ## change title status = &quot;primary&quot;, solidHeader = TRUE, plotly::plotlyOutput(NS(id, &quot;bulkseq_dots&quot;)), height = &quot;36em&quot; ), # line plot showing differential expression in different treatment groups shinydashboard::box(title = &quot;Condition&quot;, ## change title status = &quot;primary&quot;, solidHeader = TRUE, shiny::plotOutput(NS(id, &quot;bulkseq_lines&quot;)), height = &quot;36em&quot; ), br(), br() ) }, br(), # plots for experiments which divide samples into different groups e.g. different cell subtypes if (include_subtype == TRUE) { # line plots showing differential gene expression in different experiment groups in response to treatment shiny::fluidRow( shinydashboard::box(width = 12, title = &quot;Subtype Results&quot;, status = &quot;primary&quot;, solidHeader = TRUE, shiny::plotOutput(NS(id, &quot;bulkseq_lines_subtype&quot;)) ) ) },br(), # plots using differential expression data if (includedeg == TRUE) { shiny::fluidRow( shinydashboard::box(width = 6, title = &quot;Differential Gene Analysis&quot;, status = &quot;primary&quot;, solidHeader = TRUE, plotly::plotlyOutput(NS(id, &quot;deg_plot&quot;)), height = &quot;38em&quot;), # volcano plots shinydashboard::box(width = 6, title = volc_title, status = &quot;primary&quot;, solidHeader = TRUE, actionButton(NS(id, &quot;plotvolc&quot;), &quot;Plot Volcano Graphs&quot;), selectInput(NS(id, &quot;volc_pop&quot;), &quot;&quot;, choices = NULL, selected = &quot;&quot;), shiny::plotOutput(NS(id, &quot;volcanoplot&quot;), height = &quot;26em&quot;), height = &quot;38em&quot; ) ) },br(), # for displaying count data for genes selected if(includegoi == TRUE) { shiny::fluidRow( shinydashboard::box( width = 12, title = &quot;Result Table&quot;, status = &quot;primary&quot;, solidHeader = TRUE, DT::dataTableOutput(NS(id,&quot;goi_table&quot;)) ) ) },br(), # for displaying differential expression data if(includedeg == TRUE) { shiny::fluidRow( shinydashboard::box(width = 12, title = &quot;Differential Analysis Table&quot;, status = &quot;primary&quot;, solidHeader = TRUE, selectInput(NS(id, &quot;contrast&quot;), &quot;&quot;, choices = NULL, selected = &quot;&quot;), DT::dataTableOutput(NS(id, &quot;contrast_table&quot;)) ) ) } ) } 3.4.4 Network page We also provide an option for basic network analyses. The network tab contains a description box, a gene search bar, a network, a result table containing differential expression values, and a table containing information for datasets from RNA-seq and microarray studies. On the server-side, this network is generated from STRING DB and reconstructed with visNetwork. In this app, users can also colour/annotate the network based on experimental results. # UI for the network page shinydashboard::tabItem(tabName = &quot;tabnet&quot;, fluidRow( shinydashboard::box(title = &quot;Network Analysis&quot;, ## modify title as needed width = 12, status = &quot;primary&quot;, solidHeader = TRUE, ## insert description files includeHTML(&quot;des/network.Rhtml&quot;) ) ),br(), # gene search bar and filter bar fluidRow( column(width = 3, selectizeInput( inputId = &quot;gene_symbols&quot;, label = &quot;Enter Query Gene Symbols:&quot;, multiple = TRUE, choices = NULL ) ), column(width = 3, selectInput(&quot;pop&quot;, &quot;Select Experiment:&quot;, ## customize choices of datasets for different modes of annotation choices = c(&quot;Pain Enrichment Score&quot;, unique(data$experiment_id)), selected = &quot;Diabetes&quot;) ## choose one of your datasets ), column(width = 3,br(), actionButton(&quot;submit&quot;, &quot;Construct Network&quot;)), style = &quot;margin-top:20px;&quot; ), # render network fluidRow( shinydashboard::box(width = 12, status = &quot;primary&quot;, solidHeader = TRUE, title = &quot;Network&quot;, column(width = 10, visNetwork::visNetworkOutput(&quot;network&quot;, height = &quot;435px&quot;) ), height = &quot;38em&quot;, # legends column(width = 2, uiOutput(&quot;netlegend&quot;) ) ), ), br(), # result table fluidRow( shinydashboard::box(width = 12, status = &quot;primary&quot;, solidHeader = TRUE, title = &quot;Result Table&quot;, tabsetPanel( tabPanel( &quot;DEG Table&quot;, DT::dataTableOutput(&quot;contrast_table&quot;) ), tabPanel(&quot;Nodes&quot;, DT::dataTableOutput(&quot;protein_table&quot;) ) ), height = &quot;38em&quot; ) ),br(), # a table containing descriptions of experiments involved, their methods and treatment groups fluidRow( shinydashboard::box(status = &quot;primary&quot;, solidHeader = TRUE, width = 12, title = &quot;Datasets&quot;, column(width = 12, ## Insert table html files includeHTML(&quot;des/datatable.html&quot;) ), collapsible = TRUE), ) ) "],["server.html", "Chapter 4 Server 4.1 Requirements 4.2 Server Overview 4.3 Network Analysis 4.4 Functions", " Chapter 4 Server img { display:block; float:none; margin-left:auto; margin-right:auto; } Once you: 1. Have created a dataset description des_df object 2. Have changed the directory of the .db to the one you have stored your data in you can start running the app. (but lots of details are provided below so you can dive into the code) 4.1 Requirements For the Server.R page to run, you will need to create a des_df, a description df that describes your datasets. An example is shown below: Dataset: The name of the dataset disease_condition: The experimental disease group name species: the species in the experiment count_df_name: the name of the count matrix colData_name: The name of experimental design deg_df_name: the name of differential expression data type: Name of the RNA sequencing technique; either bulk or single identifier: This identifier is useful for loading description files specific for each experiment. E.g. subtype.Rhtml . Name your description files and add their names to this column. include_subtypes: This specifies if there are different subtypes of samples in the experiment. E.g. different species strains. If TRUE, there will be an additional line plot showing subtype-specific changes in gene expression. include_degs: This specifies if there are differential expression data files for this experiment. If TRUE, the visualisation page will yield differential expression dot plots and volcano plots. include_gois: Whether to display the count table on the site; i.e. some studies utilises human patient data which are sensitive to disclose. For studies like this, include_gois will be FALSE. des_df = data.frame( Dataset = c(&quot;Subtype DRG (Barry)&quot;, &quot;Mouse DRG Bulk&quot;, &quot;Rat DRG Bulk&quot;, &quot;Human iPSC HSN1&quot;, &quot;Human skin Diabetes&quot;, &quot;Human skin Carpal Tunnel (CTS)&quot;, &quot;Mouse DRG Subtype (Zheng)&quot;,&quot;Human DRG RNAseq&quot;, &quot;Human DRG spatial-seq&quot;), disease_condition = c(&quot;ipsi&quot;, &quot;SNI&quot;, &quot;SNT&quot;, &quot;patient&quot;, &quot;PDPN&quot;, &quot;pre_Surgery&quot;, &quot;&quot;, &quot;P&quot;, &quot;&quot;), species = c(&quot;mouse&quot;, &quot;mouse&quot;, &quot;rat&quot;, &quot;human&quot;, &quot;human&quot;, &quot;human&quot;, &quot;mouse&quot;, &quot;human&quot;, &quot;human&quot;), count_df_name = c(&quot;TPM_subtype&quot;, &quot;TPM_mouse&quot;, &quot;TPM_rat&quot;, &quot;TPM_ipsc&quot;, &quot;TPM_HS_diabetes&quot;, &quot;TPM_HS_CTS&quot;, &quot;TPM_zheng&quot;, &quot;TPM_humandrg&quot;, &quot;&quot;), colData_name = c(&quot;bulkseq_colData&quot;, &quot;TPM_mouse_colData&quot;, &quot;TPM_rat_colData&quot;, &quot;ipsc_colData&quot;, &quot;db_colData&quot;, &quot;skin_colData&quot;, &quot;zheng_colData&quot;, &quot;humandrg_colData&quot;, &quot;&quot;), deg_df_name = c(&quot;subtype_deg_df&quot;, &quot;mouse_deg_df&quot;, &quot;rat_deg_df&quot;, &quot;ipsc_deg_df&quot;, &quot;db_deg_df&quot;, &quot;cts_deg_df&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;), type = c(&quot;bulk&quot;,&quot;bulk&quot;,&quot;bulk&quot;,&quot;bulk&quot;,&quot;bulk&quot;,&quot;bulk&quot;,&quot;bulk&quot;,&quot;bulk&quot;, &quot;single&quot;), identifier = c(&quot;subtype&quot;, &quot;mouse&quot;, &quot;rat&quot;, &quot;ipsc&quot;, &quot;HS_diabetes&quot;, &quot;HS_CTS&quot;, &quot;zheng&quot;, &quot;humandrg&quot;, &quot;scrna&quot;), include_subtypes = c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE), include_degs = c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE), include_gois = c(TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE)) kbl(des_df %&gt;% head) %&gt;% kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;, &quot;condensed&quot;, &quot;responsive&quot;), font_size = 12, latex_options = &quot;scale_down&quot;) %&gt;% scroll_box(width = &quot;100%&quot;, height = &quot;500px&quot;) Dataset disease_condition species count_df_name colData_name deg_df_name type identifier include_subtypes include_degs include_gois Subtype DRG (Barry) ipsi mouse TPM_subtype bulkseq_colData subtype_deg_df bulk subtype TRUE TRUE TRUE Mouse DRG Bulk SNI mouse TPM_mouse TPM_mouse_colData mouse_deg_df bulk mouse FALSE TRUE TRUE Rat DRG Bulk SNT rat TPM_rat TPM_rat_colData rat_deg_df bulk rat FALSE TRUE TRUE Human iPSC HSN1 patient human TPM_ipsc ipsc_colData ipsc_deg_df bulk ipsc FALSE TRUE TRUE Human skin Diabetes PDPN human TPM_HS_diabetes db_colData db_deg_df bulk HS_diabetes FALSE TRUE FALSE Human skin Carpal Tunnel (CTS) pre_Surgery human TPM_HS_CTS skin_colData cts_deg_df bulk HS_CTS FALSE TRUE FALSE   The table names of countdata and colData for each experiment will be written. This allows the app to directly query those tables from the database object. In addition, you will need to specify directory that storing your data ## directory for scRNA sequencing data; leave it for &quot;&quot; if none scRNA_dir = &quot;data/drg.combined.rds&quot; ## a file containing themes for plots and labels for axis theme_dir = &quot;global.R&quot; ## RData that contains DEG files for network analysis network_dir = &quot;data/network.RData&quot; ## directory for the sql database db_dir = &quot;test.db&quot; 4.2 Server Overview You dont need to modify this, but is provided as an overview of the app structure. server() function is invoked each time a new session starts. When the server function is called it creates a new local environment that is independent of every other invocation of the function. This allows each session to have a unique state, as well as isolating the variables created inside the function. Server functions take three parameters: input, output, and session. The input argument is a list-like object that contains all the input data sent from ui.R, named according to the input ID. 4.2.1 Side bar Update the gene symbols entered or uploaded in files into reactive variables. # gene search bar shiny::updateSelectizeInput(session, inputId = &quot;geneid&quot;, label = &quot;Search Genes:&quot;, choices = allgenes, server = TRUE, selected = c(&quot;Trpv1&quot;, &quot;Scn10a&quot;,&quot;Atf3&quot;) ## can change to relevant genes ) # a reactive variable that records whether a file is uploaded. rv &lt;- reactiveValues( clear = FALSE, data = FALSE ) # read in files uploaded shiny::observeEvent(input$file, { rv$clear &lt;- FALSE rv$data = TRUE }, priority = 1000) # clear the file space when files are removed shiny::observeEvent(input$reset, { rv$clear = TRUE rv$data = FALSE }) # read into gene ids from files file_input &lt;- reactive({ if (rv$clear == TRUE) { return(NULL) } if(rv$clear==FALSE &amp;&amp; rv$data == TRUE) { goi = read.table(input$file$datapath) rownames(goi) &lt;- goi[,1] goi &lt;- goi[which(rownames(goi) %in% allgenes==TRUE),] return(goi)} }) genes = reactive({ if (is.null(file_input())) { genes = input$geneid } else { genes = file_input() } }) 4.2.2 Tab Menu Update active tab based on the current selection of a tab menu. ### this doesn&#39;t need to be modified shiny::observeEvent(input$metaa, { Newtab &lt;- switch(input$tabs, &quot;tabhome&quot; = &quot;tabmeta&quot;) shinydashboard::updateTabItems(session, &quot;tabs&quot;, Newtab) }) shiny::observeEvent(input$inda, { Newtab &lt;- switch(input$tabs,&quot;tabhome&quot; = &quot;tabdata&quot;) shinydashboard::updateTabItems(session, &quot;tabs&quot;, Newtab) }) shiny::observeEvent(input$neta, { Newtab &lt;- switch(input$tabs,&quot;tabhome&quot; = &quot;tabnet&quot;) shinydashboard::updateTabItems(session, &quot;tabs&quot;, Newtab) }) 4.2.3 Grouped comparisons By using the same visualization tools and methods across studies, it becomes easier to compare and integrate results from different studies. Render a table for datasets included output$meta_table = DT::renderDataTable({ DT::datatable( bulk_df[c(&quot;Dataset&quot;, &quot;Pain_Model&quot;, &quot;Species&quot;, &quot;Tissue&quot;)], ## can select relevant columns width = 6, class = &#39;nowrap&#39;, options = list(scrollX = TRUE, scrollY = TRUE, pageLength = 5), selection = &quot;none&quot; # selection = list(mode = &quot;multiple&quot;, selected = list(rows = c(1:nrow(bulk_df)), cols = c(1:4)), target = &quot;row+column&quot;) ) }) Generate homepage plots A combined gene expression dot plots A scRNA dotplot based on a Seurat object A differential expression dot plot that allows visualisation of the significance level of differential gene expression ### this doesn&#39;t need to be modified # plot in reponse to the &#39;load&#39; button observeEvent(input$load, { file_input &lt;- reactive({ if (rv$clear == TRUE) { return(NULL) } if(rv$clear==FALSE &amp;&amp; rv$data == TRUE) { goi = read.table(input$file$datapath) rownames(goi) &lt;- goi[,1] goi &lt;- goi[which(rownames(goi) %in% allgenes==TRUE),] return(goi)} }) if (is.null(file_input())) { genes = input$geneid } else { genes = file_input() } # retrieve count data of selected datasets df_list = list() selected_data = c(1:nrow(bulk_df)) for (i in selected_data){ curr = bulk_df[i,] d = curr$count if (d!=&quot;&quot;){ if (curr$Species == &quot;human&quot;){ sql = paste(&quot;SELECT * FROM&quot;, d, &quot;WHERE mgi_symbol = ?&quot;) } else { sql = paste(&quot;SELECT * FROM&quot;, d, &quot;WHERE symbol = ?&quot;) } count_data = as.data.frame(dbGetPreparedQuery(conn, sql, bind.data=data.frame(symbol=genes))) df_list = append(df_list, list(count_data)) } } # generate a data frame containing count data from all experiments final_df = generate_combine_dataset(df_list, genes, input$sex, col_list[selected_data], des_df$pain[selected_data], des_df$Species[selected_data], expression, Condition, Population, symbol, Dataset, Species) # plot the combined gene expression dot plot combine_dot = plotcombine_server(&quot;dot&quot;, final_df, input$sex, genes, Population, symbol, expression, &quot;Dataset&quot;) #dotplot if (is.null(variables$pbmc) != TRUE){ scrna_dot = plothomescdot_server(&quot;homespat&quot;, variables$pbmc, genes) } # query differential expression (DE) data frames for plotting degm = RSQLite::dbGetPreparedQuery(conn, &quot;SELECT * FROM mouse_all_deg_df WHERE symbol = ?&quot;, bind.data=data.frame(symbol=genes)) sql = &quot;SELECT * FROM rat_gene_data WHERE mgi_symbol = ?&quot; rg = as.data.frame(dbGetPreparedQuery(conn, sql, bind.data=data.frame(mgi_symbol= genes)))$rgd_symbol degr = RSQLite::dbGetPreparedQuery(conn, &quot;SELECT * FROM rat_deg_df WHERE symbol = ?&quot;, bind.data=data.frame(symbol=rg)) sql = &quot;SELECT * FROM human_gene_data WHERE mgi_symbol = ?&quot; hg = as.data.frame(dbGetPreparedQuery(conn, sql, bind.data=data.frame(mgi_symbol= genes)))$hgnc_symbol degh = RSQLite::dbGetPreparedQuery(conn, &quot;SELECT * FROM human_deg_df WHERE symbol = ?&quot;, bind.data=data.frame(symbol=hg)) # generate combined DE data frames combine_degplot = deg_combine_server(&quot;deg_plot&quot;,degr, degm, degh, Population,symbol, log2FoldChange,sig, &quot;Dataset&quot;) }) 4.2.4 Individual Analysis First, a table that contains dataset description is rendered at the top. output$dataset_table = DT::renderDataTable({ DT::datatable( des_df[c(&quot;Dataset&quot;, &quot;Pain_Model&quot;, &quot;Species&quot;, &quot;Tissue&quot;)], ## can select relevant columns width = 6, class = &#39;nowrap&#39;, options = list(scrollX = TRUE, scrollY = TRUE, pageLength = 5), selection = &quot;single&quot; ) }) Next, the ui for each independent dataset is rendered in response to row selected from the table. This is passed by the input$dataset_table_rows_selected parameter and stored into a reactive variable indrows. The parameters required for calling the shinypageUI function is retrieved from the des_df. variables = reactiveValues({ indrows = NULL }) shiny::observe({ variables$indrows =input$dataset_table_rows_selected }) output$shinypages = shiny::renderUI({ j = variables$indrows select = des_df[j,] # if a scRNA sequencing data is selected if (select$type == &quot;single&quot;){ shinyscrnapageUI(&quot;spatpage&quot;, &quot;Human DRG spatial-seq&quot;, des_dir=&quot;des/spatial.Rhtml&quot;) } else { identifier = select$Name # directory for description html files des_dir = paste(&quot;des/&quot;,identifier, &quot;.Rhtml&quot;, sep = &quot;&quot;) ## you should put your description files here # render ui shinypageUI(name, select$Dataset, select$include_degs, select$include_subtypes, des_dir = des_dir, includegoi = select$include_gois, include_count = select$include_count) } }) The server functions for each study-specific ui called is shown below. The shinypage server module contains code for generating plots and result tables. shiny::observe({ # retrieve the row number selected i = input$dataset_table_rows_selected if (is.null(i) == FALSE) { selected = des_df[i,] name = selected$Name # the scRNA seq dataset requires different UI if (selected$Dataset == &quot;Human DRG spatial-seq&quot;){ shiny::callModule(shinyscrna, &quot;spatpage&quot;, reactive({genes()}), variables$pbmc) } # for bulk RNA seq datasets else { shiny::callModule(shinypage, name, input$sex, selected$count, as.data.frame(col_list[i]), selected$Species, selected$pain, reactive({genes()}), include_deg = selected$include_degs, deg_df_name = selected$deg_df_name, dataset = selected$Dataset, include_subtype = selected$include_subtypes, include_count = selected$include_count,parent = session) } } }) 4.3 Network Analysis Network integration can give context when working with large datasets, and provide a platform to integrate information from multiple sources. Here, networks are built using proteinprotein interaction data taken from the STRING database. The network can be enriched in various ways. As an example, we have enriched the STRING networks in our example by: An Enrichment Score, an integrated statistic using data from all experiments. Differential expression in an individual experiment. Genes of interest, as a list Here, we used known pain-associated genes from various sources # update choice shiny::updateSelectizeInput(session, inputId = &quot;gene_symbols&quot;, label = &quot;Search Genes:&quot;, choices = human_gene_data$hgnc_symbol, server = TRUE, selected = c(&quot;ATF3&quot;) ## choose your favourite ) 4.3.1 Integration with STRING DB Node and edge data is extracted in real-time from STRING https://string-db.org/ and reconstructed into a network based on user input. For reference only, you dont need to modify this. ### this doesn&#39;t need to be modified # generates network when the submit button is clicked observeEvent(input$submit, { # Query gene interactions genes_list = as.vector(input$gene_symbols) genes = paste(genes_list, collapse = &quot;%0d&quot;) interactions &lt;- query_interactions(genes, 15) proteins = unique(c(unique(interactions$preferredName_A), unique(interactions$preferredName_B))) nodes = data.frame() id = unique(c(unique(interactions$stringId_A), unique(interactions$stringId_B))) nodes = as.data.frame(id) nodes$label = proteins nodes = mutate(nodes, shape = ifelse(nodes$label %in% input$gene_symbols, &quot;diamond&quot;, &quot;circle&quot;)) # annotate nodes by PES if (input$pop == &quot;Enrichment Score&quot;) { mode = &quot;meta&quot; # set metrics to PES metrics = score_df dt = score_df[score_df$symbol %in% proteins,] # legends output$netlegend = renderUI({ HTML(paste0( &quot;&lt;br&gt;&lt;br&gt;&quot;, &quot;&lt;p style = &#39;display: block; margin-left: 20px; margin-right: auto;&#39;&gt;&amp;emsp;&amp;emsp;&amp;emsp;PES&lt;/p&gt;&quot;, &quot;&lt;img style = &#39;display: block; margin-left: auto; margin-right: auto;&#39; src=&#39;bitmap.png&#39; width = &#39;80&#39; height = &#39;130&#39;&gt;&quot;,&quot;&lt;br&gt;&quot;) ) }) } # annotate by individual study else { mode = &quot;indiv&quot; # &quot;data&quot; contains DEG data for all experiments sql = paste(&quot;SELECT * FROM &quot;, input$pop, &quot;_deg_df&quot;, sep = &quot;&quot;) # filter data by the selected experiment res = data[data$experiment_id == input$pop,] res = mutate(res, sig=ifelse((res$padj&lt;0.05), &quot;SIG&quot;, &quot;NS&quot;)) # set metrics to DEG daata from a single study metrics = res dt = filter(res, symbol %in% proteins) # this means the proteins must be in human symbol rownames(dt) = dt$symbol dt = dt[c(&quot;log2FoldChange&quot;,&quot;padj&quot;, &quot;sig&quot;)] # display legend for deg output$netlegend = renderUI({ HTML(paste0( &quot;&lt;br&gt;&lt;br&gt;&quot;,&quot;&lt;p style = &#39;display: block; margin-left: 20px; margin-right: auto;&#39;&gt;&amp;emsp;&amp;emsp;&amp;emsp;LFC&lt;/p&gt; &lt;img style = &#39;display: block; margin-left: auto; margin-right: auto;&#39; src=&#39;legend.png&#39; width = &#39;80&#39; height = &#39;130&#39;&gt; &quot;,&quot;&lt;br&gt;&quot;) ) }) } # node construction using get_node() function nodes = get_nodes(interactions, gene_list, metrics, mode=mode) # construct edges edges &lt;- data.frame(from = interactions$stringId_A, to = interactions$stringId_B, width = interactions$score, color = &quot;#444444&quot;) # network visualisation nw = visNetwork::visNetwork(nodes, edges, height = &quot;500px&quot;, width = &quot;100%&quot;) %&gt;% visPhysics(enabled = FALSE,solver = &quot;forceAtlas2Based&quot;, forceAtlas2Based = list(avoidOverlap = 1)) %&gt;% visEdges(smooth = FALSE) %&gt;% visInteraction(navigationButtons = TRUE, zoomSpeed = 0.6) output$network &lt;- renderVisNetwork({nw}) # score metrics table output$contrast_table &lt;- DT::renderDataTable({ DT::datatable( dt, width = 6, class = &#39;nowrap&#39;, options = list(scrollX = TRUE, pageLength = 8) ) }) # a table containing description and information of nodes(proteins) in the PPI network output$protein_table &lt;- DT::renderDataTable({ DT::datatable( query_information(proteins), width = 6, class = &quot;wrap&quot;, options = list(scrollX = TRUE, pageLength = 8) ) }) }) 4.4 Functions An run-down of functions used throughout the app. For basic applications these dont need to be modified. A function can be called and reused multiple times by passing parameters. For this example database, functions are written for rendering plots. To illustrate them, we will use an example count dataset. 4.4.1 Data processing genes = c(&quot;Atf3&quot;, &quot;Msh6&quot;, &quot;Dlst&quot;, &quot;Slc2a9&quot;) sex = &quot;Both&quot; # load data count = read.csv(&quot;./data/CountTables/TPM_mouse.csv&quot;, header = TRUE) colData = read.csv(paste0(&quot;./data/colData/&quot;, &quot;TPM_mouse_colData.csv&quot;), header = TRUE) rownames(colData) = colData$X # filter data filt = count[count$symbol %in% genes,] matfilt = filt[,!(names(filt) %in% c(&quot;symbol&quot;))] # rename the first column colnames(matfilt) = c(&quot;gene&quot;, colnames(matfilt)[2:length(colnames(matfilt))]) rownames(matfilt) = matfilt$gene # group based on experimental conditions tcounts &lt;- t(matfilt) %&gt;% base::merge(colData, ., by=&quot;row.names&quot;) %&gt;% tidyr::gather(gene, expression, (ncol(.)-nrow(matfilt)+1):(ncol(.))) tcounts$symbol = filt[filt$X %in% tcounts$gene,]$symbol # get median expression tcounts_med = get_median(tcounts, sex, expression, Condition, Population, symbol, Dataset, Species) tcounts_med &lt;- tcounts_med[!tcounts_med$Condition %in% &quot;SNI&quot;, ] # remove pain samples #&#39; a function that gets the median expression of a count data get_median &lt;- function(df, sex, var, ...){ ifelse(sex==&quot;Both&quot;, data &lt;- df %&gt;% dplyr::group_by(...) %&gt;% dplyr::summarise(expression=median(as.double({{var}}))), df &lt;- tcounts %&gt;% dplyr::group_by(..., Sex) %&gt;% dplyr::summarise(expression=median(as.double({{var}})))) return(data) } 4.4.2 Dot plots median counts (here, transcripts per million (TPM)) plot_dotplot &lt;- function(data, x_var, y_var, col_var, facet_var, sex){ x_var = enquo(x_var) y_var = enquo(y_var) col_var = enquo(col_var) g = ggplot2::ggplot(data = data, aes(x=!!x_var, y = !!y_var)) + scale_colour_viridis_c(option = &quot;magma&quot;, end = .90) + geom_point(aes(col=log(!!col_var), size=log(!!col_var))) + facet_grid(.~.data[[facet_var]], scales = &quot;free&quot;, space=&quot;free&quot;) + scale_x_discrete(labels=population_labels) + labs(col=&quot;log(TPM)&quot;, size = &quot;&quot;) + guides(size = &quot;none&quot;) # add themes g = g + theme_bw() + theme(panel.grid = element_blank(), axis.title = element_blank(), axis.text.x = element_text(size=8, angle = 45, hjust= 1), axis.text.y = element_text(size=10), axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), legend.justification = c(0,0.3), strip.text.x = element_text(size = 9, margin = margin(6, 2, 6, 2)), panel.spacing = unit(0.25, &quot;mm&quot;)) if (sex == &quot;Separate&quot;) { g = g + facet_wrap(~Sex, labeller = labeller(Sex = sexlabels), scales =&quot;free_x&quot;) } return(g) } dotplot = plot_dotplot(tcounts_med, Population, symbol, expression, &quot;Dataset&quot;, sex) print(dotplot) 4.4.3 Line plots Median gene expression in case and control conditions Linetype is encoded by the timepoint of treatment group (if exists) #&#39; @param group_vars symbol, Timepoint #&#39; @param linetype_var Timepoint #&#39; plot_lineplot &lt;- function(data,sex, x_var, y_var, col_var, linetype_var, ...){ x_var = enquo(x_var) y_var = enquo(y_var) col_var = enquo(col_var) group_vars = enquos(...) linetype_var = enquo(linetype_var) theme_line = theme_bw() + theme(panel.grid = element_blank(), axis.title = element_text(size=12), axis.text.x = element_text(size=10, angle = 45, hjust= 1), axis.text.y = element_text(size=10), axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), legend.justification = c(0,0.3)) lineplot = ggplot2::ggplot(data, aes(x=!!x_var, y=!!y_var, group=interaction(!!!group_vars))) + scale_colour_viridis(discrete=TRUE, end = .80) + geom_line(aes(color=!!col_var, linetype=!!linetype_var)) + geom_point(aes(col=!!col_var)) + theme_line + ylab(&quot;Expression&quot;) + guides(linetype=guide_legend(label.hjust=0.5)) if (sex ==&#39;Separate&#39;){ lineplot = lineplot + facet_wrap(~Sex, labeller = labeller(Sex = sexlabels), scales = &quot;free_x&quot;) + labs(col=&quot;&quot;) } return(lineplot) } tcounts_m = get_median(tcounts, sex, var = expression, Condition, symbol, Timepoint, Dataset, Species) lineplot = plot_lineplot(tcounts_m, sex, Condition, expression, symbol, Timepoint, symbol, Timepoint) print(lineplot) 4.4.4 A differential expression dot plot Colour intensity encodes the log2 fold change Dot represents if the change is significant (filled) or not (unfilled). plot_degplot &lt;- function(data, x_var, y_var, col_var, shape_var){ x_var = enquo(x_var) y_var = enquo(y_var) col_var = enquo(col_var) shape_var = enquo(shape_var) degplot = ggplot2::ggplot(data, aes(x=interaction(!!x_var), y = !!y_var, text = paste(&#39;padj: &#39;,padj))) + scale_colour_viridis_c(option = &quot;viridis&quot;, end = .90) + geom_point(aes(col=!!col_var, shape=!!shape_var, size=0.5)) + scale_shape_manual(values=c(1, 19)) + labs(shape = &quot;&quot;, size = &quot;&quot;) + scale_x_discrete(labels=subpopulation_labels) + guides(size = &quot;none&quot;) degplot = degplot + theme_bw() + theme(panel.grid = element_blank(), axis.title = element_blank(), axis.text.x = element_text(size=8, angle = 45, hjust= 1), axis.text.y = element_text(size=10), axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), legend.justification = c(0,0.3), strip.text.x = element_text(size = 9, margin = margin(6, 2, 6, 2)), panel.spacing = unit(0.25, &quot;mm&quot;)) return(degplot) } degplot = plot_degplot(deg_df, Population, symbol, log2FoldChange, sig) print(degplot) 4.4.5 A volcano plot showing case vs control samples genes of interest are labelled using colour. plot_volcanoplot &lt;- function(data, il_genes, x_var, y_var, label_var){ x_var = enquo(x_var) y_var = enquo(y_var) label_var = enquo(label_var) volcanoplot = ggplot2::ggplot(data = data, aes(x = !!x_var, y = !!y_var)) + geom_point(colour = &quot;grey&quot;, alpha = 0.5) + geom_point(data = il_genes, # New layer containing data subset il_genes size = 2, shape = 21, fill = &quot;firebrick&quot;, colour = &quot;black&quot;) + geom_hline(yintercept = -log10(0.05), linetype = &quot;dashed&quot;) + geom_vline(xintercept = c(log2(0.5), log2(2)), linetype = &quot;dashed&quot;) + geom_label_repel(data = il_genes, aes(label = !!label_var), force = 2, nudge_y = 1) + # scale_colour_manual(values = cols) + scale_x_continuous(breaks = c(seq(-10, 10, 2)), limits = c(-10, 10)) + # theme_line + labs(y=&quot;-log10(FDR)&quot;) return(volcanoplot) } res = mutate(deg, log10fdr=-log10(padj)) volc_df = res[res$symbol %in% genes,] volcanoplot = plot_volcanoplot(res, volc_df, log2FoldChange, log10fdr, symbol) print(volcanoplot) ## Warning: Removed 31279 rows containing missing values (`geom_point()`). 4.4.6 Other A downloadable R Markdown report can be generated by clicking the Generate Code button, as shown below. # download a R markdown report output$combineplot &lt;- downloadHandler( filename = &quot;RNAseq_homeplot.html&quot;, content = function(file) { params &lt;- list(matrix = final_df, genes = genes, sex = input$sex, scRNA = variables$pbmc, ratdeg = degr, mousedeg = degm, humandeg = degh, human_gene_data = human_gene_data) shiny::withProgress(value = 0, message = &#39;Rendering plotting report&#39;, detail = &#39;This might take several minutes.&#39;,{ rmarkdown::render(input = &quot;reports/combineplot.Rmd&quot;, params = params, output_file = file, envir = new.env(parent = globalenv())) }) } ) # closure for download handler The plots can also be downloaded as a zip file via a download button Download Data. # download all plots into a zip output$combineplots &lt;- downloadHandler( filename = function() { paste(&quot;combined&quot;, &quot;zip&quot;, sep=&quot;.&quot;) }, content = function(file){ # Set temporary working directory owd &lt;- setwd(tempdir()) on.exit(setwd(owd)) fs = c() # Save the plots ggsave(&#39;combine_deg.png&#39;, plot = combine_degplot, width = 14, height = 6, dpi = 300, units = &quot;in&quot;, device=&#39;png&#39;) ggsave(&#39;combine_dot.png&#39;, plot = combine_dot, width = 14, height = 6, dpi = 300, units = &quot;in&quot;, device=&#39;png&#39;) ggsave(&#39;scrna_dot.png&#39;, plot = scrna_dot, width = 10, height = 8, dpi = 300, units = &quot;in&quot;, device=&#39;png&#39;) fs = c(fs, &#39;combine_deg.png&#39;) fs = c(fs, &#39;combine_dot.png&#39;) fs = c(fs, &#39;scrna_dot.png&#39;) # csv files for gene count data write.csv(final_df,&quot;result_table.csv&quot;, row.names = FALSE, col.names = TRUE) fs = c(fs, &quot;result_table.csv&quot;) zip(file, fs) } ) "],["deploy.html", "Chapter 5 Deploying your application 5.1 Shinyapps.io 5.2 Bioconductor", " Chapter 5 Deploying your application 5.1 Shinyapps.io Sign up to https://www.shinyapps.io/. Your university may already have a subscription, otherwise you can use a free plan to host your app. 5.2 Bioconductor Before deploying, you should specific the bioconductor repository (depending on updates, a very new version may be incompatible with Shiny briefly). You can also check which repositories have been set using getOption(\"repos\"). setRepositories(addURLs = c(BioC = &quot;https://bioconductor.org/packages/3.16/bioc&quot;)) #specify version here And, DEPLOY! (this may take awhile). If you are using RStudio, you can also deploy using the blue icon in the top-right corner. rsconnect::deployApp() Still not working? Check our troubleshooting guide (6) for more help. It may be as simple as turning off your firewall. "],["trouble.html", "Chapter 6 Troubleshooting 6.1 Package installation 6.2 File setup 6.3 Styling 6.4 Data input/output issues 6.5 Debugging reactive code 6.6 Deployment", " Chapter 6 Troubleshooting 6.1 Package installation Most packages are installed from CRAN using install.packages or bioconductor using BiocManager::install(). Make sure to also install dependencies, and check to see which functions are masked by other packages if you change the order of loading libraries. Some require installation from github, using devtools. For example, dict installation: if (!require(&quot;devtools&quot;)) install.packages(&quot;devtools&quot;) devtools::install_github(&quot;mkuhn/dict&quot;) If you are using Windows and struggling with compilation, make sure RTools is installed properly (https://cran.r-project.org/bin/windows/Rtools/rtools42/rtools.html). If you dont have write permissions to update packages, this may require administrator access. 6.2 File setup The most common error is that your file names or PATH is incorrect. 6.3 Styling If you are using a style sheet (style.css), first make sure its in the correct repository. Are default options from Shiny overriding the options in your style sheet? Check options for each function. For more help, see https://shiny.rstudio.com/articles/css.html. # example fluidRow tabItem(tabName = tabName, fluidRow(box(title = datasetTitle, status = &quot;primary&quot;, # these with affect styling solidHeader = TRUE, # these with affect styling if (is.null(des_dir) == FALSE) {includeHTML(des_dir)}, if (is.null(image_dir) == FALSE) {img(src = image_dir, height = 150, width = 400)} )),br(), actionLink(NS(id, &quot;link_to_home&quot;), &quot;Home&quot;, icon = icon(&quot;home&quot;)),br(),br(), actionButton(NS(id, &quot;load&quot;), &quot;Plot Graphs&quot;) ) 6.4 Data input/output issues Ensure that the data you are inputting into the app is in the correct format, and that the output is being generated correctly. Check if there are any issues with the data or if there are errors in the code that is manipulating the data. You can print data at each step of pre-processing to evaluate their format. An example is the step of calculating median expression from all samples and grouping them based on experimental parameters. Use print() function throughout to monitor mistakes. # load count data and colData count = read.csv(&quot;./data/CountTables/TPM_mouse.csv&quot;, header = TRUE) count$gene = count$X ## print(count) colData = read.csv(paste0(&quot;./data/colData/&quot;, &quot;TPM_mouse_colData.csv&quot;), header = TRUE) rownames(colData) = colData[,1] ## print(colData) # filter rows of genes queried df = count[count$symbol %in% c(&quot;Gnai3&quot;, &quot;Scml12&quot;),] ## print(df) # remove the symbol column df$gene = df$X filt = df[,!names(df) %in% c(&quot;symbol&quot;,&quot;X&quot;)] rownames(filt) = filt$gene ## print(filt) # convert wide to long data frame based on the rownames of colData and rownames of count data # this requires rownames(tcounts) to be gene IDs and rownames(colData) to be the same as colnames(tcounts) # mistakes are generated if those columns do not match. tcounts &lt;- t(filt) %&gt;% base::merge(colData, ., by=&quot;row.names&quot;) %&gt;% gather(gene, expression, (ncol(.)-nrow(filt)+1):(ncol(.))) ## print(tcounts) # add back symbols tcounts$symbol = count[count$X %in% tcounts$gene,]$symbol ## print(tcounts) # display datasets kbl(tcounts %&gt;% head) %&gt;% kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;, &quot;condensed&quot;, &quot;responsive&quot;), font_size = 12, latex_options = &quot;scale_down&quot;) %&gt;% scroll_box(width = &quot;100%&quot;, height = &quot;200px&quot;) Row.names X Sample Population Condition Sex Sample_Pop_Cond_Sex Dataset Species Timepoint gene expression symbol Sample49_BALB.c_SNI_M Sample49_BALB.c_SNI_M Sample49 BALB.c SNI M Sample49_BALB.c_SNI_M Bulk DRG Mouse (DRG) na ENSMUSG00000000001 23.24143 Gnai3 Sample50_BALB.c_SHAM_M Sample50_BALB.c_SHAM_M Sample50 BALB.c SHAM M Sample50_BALB.c_SHAM_M Bulk DRG Mouse (DRG) na ENSMUSG00000000001 20.64601 Gnai3 Sample51_BALB.c_SHAM_M Sample51_BALB.c_SHAM_M Sample51 BALB.c SHAM M Sample51_BALB.c_SHAM_M Bulk DRG Mouse (DRG) na ENSMUSG00000000001 20.96847 Gnai3 Sample55_BALB.c_SHAM_F Sample55_BALB.c_SHAM_F Sample55 BALB.c SHAM F Sample55_BALB.c_SHAM_F Bulk DRG Mouse (DRG) na ENSMUSG00000000001 25.60511 Gnai3 Sample56_BALB.c_SHAM_F Sample56_BALB.c_SHAM_F Sample56 BALB.c SHAM F Sample56_BALB.c_SHAM_F Bulk DRG Mouse (DRG) na ENSMUSG00000000001 17.92455 Gnai3 Sample57_BALB.c_SHAM_F Sample57_BALB.c_SHAM_F Sample57 BALB.c SHAM F Sample57_BALB.c_SHAM_F Bulk DRG Mouse (DRG) na ENSMUSG00000000001 21.82794 Gnai3 6.5 Debugging reactive code Reavtive components respond to user inputs. This allows users to interact with the data in real-time, updating visualizations and other content as they change settings or filters. Reactive components can be created using the reactive() function in Shiny. An example is shown below: For example, library(shiny) # Define the UI ui &lt;- fluidPage( # Input field for a number numericInput(inputId = &quot;my_number&quot;, label = &quot;Enter a number:&quot;, value = 1), # Text output for the number squared textOutput(outputId = &quot;my_output&quot;) ) # Define the server server &lt;- function(input, output) { # Define a reactive expression for the square of the number squared &lt;- reactive({ input$my_number^2 }) # Output the squared number to the text output output$my_output &lt;- renderText({ paste0(&quot;The square of &quot;, input$my_number, &quot; is &quot;, squared()) }) } # Run the app shinyApp(ui, server) The example above uses the numericInput() function to create an input field where the user can enter a number. We then use the reactive() function to define a reactive expression called squared, which calculates the square of the input number. Finally, we use the renderText() function to display the squared number in a text output component. Note that the squared reactive expression is not evaluated until it is actually used in the renderText() function. This means that it will only be re-evaluated when the input value my_number changes. To debug reactive code, there are a few tips. Use the print() function to print out intermediate results of the reactive code to see where the problem is arising. For example, you can print the value of a reactive input or output to see if it is being calculated correctly. You can also use the reactiveValues() function to create reactive values that can be printed out for debugging purposes. # Example of using print statements to debug reactive code output$my_output &lt;- renderText({ x &lt;- input$my_input print(x) # Print the value of x for debugging purposes x * 2 # Return the value of x times 2 }) Use the browser() function to pause the execution of the code at a particular point, which will allow you to inspect the current environment. This can be particularly useful for debugging complex reactive code. To use the browser() function, simply add it to the reactive expression where you want to pause the code. # Example of using the browser function to debug reactive code output$my_output &lt;- renderText({ x &lt;- input$my_input browser() # Pause execution and allow user to inspect environment x * 2 # Return the value of x times 2 }) When the app runs and the server function is called, it will pause at the browser() statement. In the R console or IDE, you can then examine the value of the input variable by typing input at the prompt, or check the current state of the app by typing other R commands. Once you are finished debugging, you can continue the app execution by typing c (for continue) in the R console. The app will resume execution and the output will be displayed in the Shiny app UI. Check for dependencies: Reactive expressions can sometimes depend on other reactive expressions or reactive values, and it can be challenging to trace the dependencies. The reactiveLog() function in the reactlog package can be useful for visualizing the dependencies between reactive expressions. library(shiny) library(shinydebug) ui &lt;- fluidPage( textInput(&quot;name&quot;, &quot;Enter your name:&quot;), verbatimTextOutput(&quot;greeting&quot;) ) server &lt;- function(input, output) { # Use reactiveLog() to log the execution of the reactive expression reactiveLog({ name &lt;- input$name paste0(&quot;Hello, &quot;, name, &quot;!&quot;) }, label = &quot;greeting&quot;) # Render the greeting text in the output output$greeting &lt;- renderText({ reactiveValuesToList(reactiveLogData()$greeting$value)[[1]] }) } shinyApp(ui, server) In this example, were using reactiveLog() to log the execution of a reactive expression that generates a greeting message based on the users input. Were also using the label argument to assign a label to the reactive expression, which will be used to identify it in the log. When the app runs, the reactiveLog() function will log the execution of the reactive expression and display it in the R console or IDE, along with a timestamp and the label. You can use the log to observe the order in which reactive expressions are executed and identify any issues or unexpected behavior. In the output$greeting function, were using reactiveLogData() to retrieve the log data for the greeting label, and then extracting the value of the reactive expression using reactiveValuesToList(). This allows us to render the greeting text in the app output. Use tryCatch(): If your reactive code is throwing errors, you can use the tryCatch() function to catch the errors and display a custom error message. This can be useful for debugging errors that occur during reactive code execution. # Example of using the tryCatch function to catch errors in reactive code output$my_output &lt;- renderText({ tryCatch({ x &lt;- input$my_input x * 2 # Return the value of x times 2 }, error = function(e) { &quot;An error occurred while calculating the output.&quot; # Display a custom error message }) }) 6.6 Deployment Simple apps can be directly deployed with rsconnect::deployApp(), but it is common to have issues with the first deployment even when the app works locally. Here are a few examples below, but your error code will help inform a starting point (in particular, is there one package highlighted as a potential issue?) 6.6.1 Basics Slow deployment: Uploading bundle for application and building packages will take time. Are you loading unneccessary data or packages? Memory: check Instance Size on shinyapps.io, this can be increased with specific pricing packages. 6.6.2 Bioconductor Because this framework uses Biocondutor packages, it is likely you need to set the repository (URL). # example error 1: you need to set a URL May be unable to deploy package dependency &#39;AnnotationDbi&#39;; could not determine a repository URL for the source &#39;Bioconductor&#39;. # example error 2: the URL is set but not sufficient to compile packages, may need to try another Bioconductor version, update packages, fix compiling, turn off a firewall, or update R Unhandled Exception: Child Task 873781155 failed: Error parsing manifest: Unable to determine package source for Bioconductor package # example error 3: you likely have a mismatch in versions across packages, which may be compatible locally by cause issues on shinyapp.io. Here, use BiocManager::valid() to ensure all packages are in agreement Error: Unhandled Exception: Child Task 1278414280 failed: Error building image: Error fetching GenomeInfoDbData (1.2.9) source. Error downloading package source. Please update your BioConductor packages to the latest version and try again Example (truncated) output from BiocManager::valid(). If you need to compile something by source to get the most recent version, make sure have installed the required packages (eg. RTools for Windows). BiocManager::valid() # Bioconductor version &#39;3.16&#39; # # * 1 packages out-of-date # * 0 packages too new # # create a valid installation with # # BiocManager::install(&quot;sfheaders&quot;, update = TRUE, ask = FALSE, force = TRUE) ## run this part to fix # # more details: BiocManager::valid()$too_new, BiocManager::valid()$out_of_date # You can specific the bioconductor repository here (depending on updates, a very new version may be incompatible with Shiny briefly). You can check which repositories have been set using getOption(\"repos\"). setRepositories(addURLs = c(BioC = &quot;https://bioconductor.org/packages/3.16/bioc&quot;)) #specify version here # alternatively, this can be run at the top of the UI and *may* help library(BiocManager) options(repos = BiocManager::repositories()) If there is a specific package referred to, check the installation to make sure it was successful (see above). You can force a new install using force = TRUE, but restart R before trying again. If you are planning to update many packages, you can check which are valid first. BiocManager::valid() Still not working? A few other things to look for: Package dependency mismatch between CRAN and Bioconductor (check rsconnect::appDependencies()) Make sure you are using a released version of R (shinyapps.io doesnt support beta versions, and you may need to revert to a released version of R and update packages.) Your local firewall/antivirus may be blocking deployment. If all else fails, try posting on the community forum for help (&lt;https://community.rstudio.com/) and tag Shiny and shinyapp.io with a reproducible example (ie. reprex). See https://community.rstudio.com/t/faq-tips-for-writing-r-related-questions/6824 for how to best format this. For reference, the following were used for our database. rsconnect::appDependencies() ## package version source ## 1 AnnotationDbi 1.60.0 Bioconductor ## 2 Biobase 2.58.0 Bioconductor ## 3 BiocFileCache 2.6.1 Bioconductor ## 4 BiocGenerics 0.44.0 Bioconductor ## 5 Biostrings 2.66.0 Bioconductor ## 6 DBI 1.1.3 CRAN ## 7 GenomeInfoDb 1.34.9 Bioconductor ## 8 GenomeInfoDbData 1.2.9 Bioconductor ## 9 IRanges 2.32.0 Bioconductor ## 10 KEGGREST 1.38.0 Bioconductor ## 11 MASS 7.3-58.2 CRAN ## 12 Matrix 1.5-3 CRAN ## 13 R6 2.5.1 CRAN ## 14 RColorBrewer 1.1-3 CRAN ## 15 RCurl 1.98-1.10 CRAN ## 16 RSQLite 2.3.0 CRAN ## 17 Rcpp 1.0.10 CRAN ## 18 S4Vectors 0.36.2 Bioconductor ## 19 XML 3.99-0.13 CRAN ## 20 XVector 0.38.0 Bioconductor ## 21 askpass 1.1 CRAN ## 22 base64enc 0.1-3 CRAN ## 23 biomaRt 2.54.0 Bioconductor ## 24 bit 4.0.5 CRAN ## 25 bit64 4.0.5 CRAN ## 26 bitops 1.0-7 CRAN ## 27 blob 1.2.3 CRAN ## 28 bookdown 0.32 CRAN ## 29 bslib 0.4.2 CRAN ## 30 cachem 1.0.7 CRAN ## 31 callr 3.7.3 CRAN ## 32 cli 3.6.0 CRAN ## 33 colorspace 2.1-0 CRAN ## 34 cpp11 0.4.3 CRAN ## 35 crayon 1.5.2 CRAN ## 36 curl 5.0.0 CRAN ## 37 dbplyr 2.3.1 CRAN ## 38 digest 0.6.31 CRAN ## 39 dplyr 1.1.0 CRAN ## 40 ellipsis 0.3.2 CRAN ## 41 evaluate 0.20 CRAN ## 42 fansi 1.0.4 CRAN ## 43 farver 2.1.1 CRAN ## 44 fastmap 1.1.1 CRAN ## 45 filelock 1.0.2 CRAN ## 46 fs 1.6.1 CRAN ## 47 generics 0.1.3 CRAN ## 48 ggplot2 3.4.1 CRAN ## 49 ggrepel 0.9.3 CRAN ## 50 glue 1.6.2 CRAN ## 51 gridExtra 2.3 CRAN ## 52 gtable 0.3.1 CRAN ## 53 highr 0.10 CRAN ## 54 hms 1.1.2 CRAN ## 55 htmltools 0.5.4 CRAN ## 56 httr 1.4.5 CRAN ## 57 isoband 0.2.7 CRAN ## 58 jquerylib 0.1.4 CRAN ## 59 jsonlite 1.8.4 CRAN ## 60 kableExtra 1.3.4 CRAN ## 61 knitr 1.42 CRAN ## 62 labeling 0.4.2 CRAN ## 63 lattice 0.20-45 CRAN ## 64 lifecycle 1.0.3 CRAN ## 65 magrittr 2.0.3 CRAN ## 66 memoise 2.0.1 CRAN ## 67 mgcv 1.8-41 CRAN ## 68 mime 0.12 CRAN ## 69 munsell 0.5.0 CRAN ## 70 nlme 3.1-162 CRAN ## 71 openssl 2.0.5 CRAN ## 72 packrat 0.9.1 CRAN ## 73 pillar 1.8.1 CRAN ## 74 pkgconfig 2.0.3 CRAN ## 75 plogr 0.2.0 CRAN ## 76 png 0.1-8 CRAN ## 77 prettyunits 1.1.1 CRAN ## 78 processx 3.8.0 CRAN ## 79 progress 1.2.2 CRAN ## 80 ps 1.7.2 CRAN ## 81 purrr 1.0.1 CRAN ## 82 rappdirs 0.3.3 CRAN ## 83 rlang 1.0.6 CRAN ## 84 rmarkdown 2.20 CRAN ## 85 rsconnect 0.8.29 CRAN ## 86 rstudioapi 0.14 CRAN ## 87 rvest 1.0.3 CRAN ## 88 sass 0.4.5 CRAN ## 89 scales 1.2.1 CRAN ## 90 selectr 0.4-2 CRAN ## 91 stringi 1.7.12 CRAN ## 92 stringr 1.5.0 CRAN ## 93 svglite 2.1.1 CRAN ## 94 sys 3.4.1 CRAN ## 95 systemfonts 1.0.4 CRAN ## 96 tibble 3.1.8 CRAN ## 97 tidyr 1.3.0 CRAN ## 98 tidyselect 1.2.0 CRAN ## 99 tinytex 0.44 CRAN ## 100 utf8 1.2.3 CRAN ## 101 vctrs 0.5.2 CRAN ## 102 viridis 0.6.2 CRAN ## 103 viridisLite 0.4.1 CRAN ## 104 webshot 0.5.4 CRAN ## 105 withr 2.5.0 CRAN ## 106 xfun 0.37 CRAN ## 107 xml2 1.3.3 CRAN ## 108 yaml 2.3.7 CRAN ## 109 zlibbioc 1.44.0 Bioconductor getOption(&quot;repos&quot;) ## CRAN ## &quot;https://cran.rstudio.com/&quot; ## attr(,&quot;RStudio&quot;) ## [1] TRUE sessionInfo() ## R version 4.2.2 (2022-10-31 ucrt) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 19042) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=English_United Kingdom.1252 LC_CTYPE=English_United Kingdom.1252 LC_MONETARY=English_United Kingdom.1252 ## [4] LC_NUMERIC=C LC_TIME=English_United Kingdom.1252 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] viridis_0.6.2 viridisLite_0.4.1 biomaRt_2.54.0 ggrepel_0.9.3 ggplot2_3.4.1 kableExtra_1.3.4 stringr_1.5.0 RSQLite_2.3.0 ## [9] tidyr_1.3.0 dplyr_1.1.0 ## ## loaded via a namespace (and not attached): ## [1] Biobase_2.58.0 httr_1.4.5 sass_0.4.5 bit64_4.0.5 jsonlite_1.8.4 bslib_0.4.2 ## [7] BiocManager_1.30.20 highr_0.10 stats4_4.2.2 BiocFileCache_2.6.1 blob_1.2.3 GenomeInfoDbData_1.2.9 ## [13] yaml_2.3.7 progress_1.2.2 pillar_1.8.1 glue_1.6.2 digest_0.6.31 XVector_0.38.0 ## [19] rvest_1.0.3 colorspace_2.1-0 htmltools_0.5.4 XML_3.99-0.13 pkgconfig_2.0.3 bookdown_0.32 ## [25] zlibbioc_1.44.0 purrr_1.0.1 scales_1.2.1 webshot_0.5.4 svglite_2.1.1 tibble_3.1.8 ## [31] KEGGREST_1.38.0 farver_2.1.1 generics_0.1.3 IRanges_2.32.0 ellipsis_0.3.2 cachem_1.0.7 ## [37] withr_2.5.0 BiocGenerics_0.44.0 cli_3.6.0 magrittr_2.0.3 crayon_1.5.2 memoise_2.0.1 ## [43] evaluate_0.20 fansi_1.0.4 xml2_1.3.3 rsconnect_0.8.29 tools_4.2.2 prettyunits_1.1.1 ## [49] hms_1.1.2 lifecycle_1.0.3 S4Vectors_0.36.2 munsell_0.5.0 packrat_0.9.1 AnnotationDbi_1.60.0 ## [55] Biostrings_2.66.0 compiler_4.2.2 jquerylib_0.1.4 GenomeInfoDb_1.34.9 systemfonts_1.0.4 rlang_1.0.6 ## [61] grid_4.2.2 RCurl_1.98-1.10 rstudioapi_0.14 rappdirs_0.3.3 labeling_0.4.2 bitops_1.0-7 ## [67] rmarkdown_2.20 gtable_0.3.1 DBI_1.1.3 curl_5.0.0 R6_2.5.1 gridExtra_2.3 ## [73] knitr_1.42 fastmap_1.1.1 bit_4.0.5 utf8_1.2.3 filelock_1.0.2 stringi_1.7.12 ## [79] Rcpp_1.0.10 vctrs_0.5.2 png_0.1-8 dbplyr_2.3.1 tidyselect_1.2.0 xfun_0.37 Happy building! "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
